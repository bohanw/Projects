(*---------------------------------------------------------------------------*)
(* Brzozowski's paper on taking the derivative of a regular expression       *)
(* allows the language of regular expressions to be expanded to include      *)
(* any boolean operator.                                                     *)
(*---------------------------------------------------------------------------*)

quietdec := true;
open arithmeticTheory listTheory;
quietdec := false;

(*---------------------------------------------------------------------------*)
(* Basic list facts                                                          *)
(*---------------------------------------------------------------------------*)

val NULL_EQ_NIL = Q.prove
(`!l. NULL l = (l = [])`,
 Cases THEN RW_TAC list_ss []);

val FLAT_EQ_NIL = Q.prove
(`!wlist. (FLAT wlist = []) = EVERY NULL wlist`,
 Induct THEN RW_TAC list_ss [FLAT,NULL_EQ_NIL]);

val NULL_FLAT_THM = Q.prove
(`!L. NULL (FLAT L) = EVERY NULL L`,
 METIS_TAC [FLAT_EQ_NIL, NULL_EQ_NIL]);

val FLAT_APPEND_DISTRIB = Q.prove
(`!l1 l2. FLAT (l1 ++ l2) = FLAT l1 ++ FLAT l2`,
 Induct THEN RW_TAC list_ss [FLAT]);

val FIRST_EXISTS_THM = Q.prove
(`!P L. EXISTS P L ==>
      ?prefix w suffix. 
        (L = prefix ++ [w] ++ suffix) /\ EVERY ($~ o P) prefix /\ P w`,
 GEN_TAC THEN Induct THEN RW_TAC list_ss []
  THEN FULL_SIMP_TAC list_ss [EXISTS_DEF] THEN RW_TAC list_ss []
  THENL [MAP_EVERY Q.EXISTS_TAC [`[]`, `h`, `L`] THEN RW_TAC list_ss [],
         Cases_on `P h` THENL
         [MAP_EVERY Q.EXISTS_TAC [`[]`, `h`, `prefix ++ [w] ++ suffix`] 
            THEN RW_TAC list_ss [],
          MAP_EVERY Q.EXISTS_TAC [`h::prefix`, `w`, `suffix`] THEN 
          RW_TAC list_ss [combinTheory.o_DEF]]]);


(*---------------------------------------------------------------------------*)
(* Datatype of extended regular expressions.                                 *)
(*---------------------------------------------------------------------------*)

Hol_datatype 
   `regex = Empty 
          | Epsilon
          | Any
          | Symbol of 'a
          | Not of regex
          | Or of regex => regex
          | And of regex => regex
          | Then of regex => regex
          | Star of regex
          | Prefix of regex`;

(*---------------------------------------------------------------------------*)
(* Parser fiddling to get +, &, and # as infixes.                            *)
(*---------------------------------------------------------------------------*)

val _ = overload_on ("+", Term`$Or`);
val _ = overload_on ("&", Term`$And`);
val _ = overload_on ("#", Term`$Then`);

val _ = set_fixity "+" (Infixr 501);   (* Reset assoc. of + to R-assoc *)
val _ = set_fixity "&" (Infixr 551);
val _ = set_fixity "#" (Infixr 601);

(*---------------------------------------------------------------------------*)
(* Semantics. "sem r w" means w is a member of the language generated by r.  *)
(*---------------------------------------------------------------------------*)

val sem_def =
 Define
  `(sem Empty w      = F)                                               /\
   (sem Epsilon w    = (w = []))                                        /\
   (sem Any w        = ?c. w = [c])                                     /\
   (sem (Symbol c) w = (w = [c]))                                       /\
   (sem (Not r) w    = ~sem r w)                                        /\
   (sem (r1 + r2) w  = sem r1 w \/ sem r2 w)                            /\
   (sem (r1 & r2) w  = sem r1 w /\ sem r2 w)                            /\
   (sem (r1 # r2) w  = ?w1 w2. (w = w1++w2) /\ sem r1 w1 /\ sem r2 w2)  /\
   (sem (Star r) w   = ?wlist. (w = FLAT wlist) /\ EVERY (sem r) wlist) /\
   (sem (Prefix r) w = ?w'. sem r (w ++ w'))`;


(*---------------------------------------------------------------------------*)
(* Basic identities                                                          *)
(*---------------------------------------------------------------------------*)

val OrEmpty = Q.prove
(`(!r. sem (r + Empty) = sem r) /\ 
  (!r. sem (Empty + r) = sem r)`,
 RW_TAC list_ss [FUN_EQ_THM,sem_def]);

val OrIdem = Q.prove
(`!r. sem (r + r) = sem r`,
 RW_TAC list_ss [FUN_EQ_THM,sem_def]);

val ThenEmpty = Q.prove
(`(!r. sem (r#Empty) = sem Empty) /\ 
  (!r. sem (Empty#r) = sem Empty)`,
 RW_TAC list_ss [FUN_EQ_THM,sem_def]);

val ThenEpsilon = Q.prove
(`(!r. sem (r#Epsilon) = sem r) /\ 
  (!r. sem (Epsilon#r) = sem r)`,
 RW_TAC list_ss [FUN_EQ_THM,sem_def]);

val OrAssoc = Q.prove
(`!r1 r2 r3. sem ((r1 + r2) + r3) = sem (r1 + (r2 + r3))`,
 RW_TAC list_ss [FUN_EQ_THM,sem_def] THEN METIS_TAC []);

val AndAssoc = Q.prove
(`!r1 r2 r3. sem ((r1 & r2) & r3) = sem (r1 & (r2 & r3))`,
 RW_TAC list_ss [FUN_EQ_THM,sem_def] THEN METIS_TAC []);

val ThenAssoc = Q.prove
(`!r1 r2 r3. sem ((r1 # r2) # r3) = sem (r1 # (r2 # r3))`,
 RW_TAC list_ss [FUN_EQ_THM,sem_def] THEN METIS_TAC [APPEND_ASSOC]);

val StarDisjThm = Q.prove
(`!r w.sem (Star r) w = sem (Epsilon + (r # Star r)) w`,
 RW_TAC std_ss [] THEN EQ_TAC THEN RW_TAC list_ss [sem_def, FLAT] 
 THENL [Cases_on `wlist` THEN RW_TAC list_ss [FLAT], ALL_TAC, ALL_TAC]
 THEN METIS_TAC [FLAT,EVERY_DEF]);

val StarThenThm = Q.prove
(`!r w.sem (Star r) w ==> ?n.sem (FUNPOW ($# r) n Epsilon) w`,
 RW_TAC list_ss [sem_def, FLAT, FUNPOW_SUC] 
   THEN Q.EXISTS_TAC `LENGTH wlist` 
   THEN Induct_on `wlist` 
   THEN RW_TAC list_ss [sem_def, FLAT, FUNPOW_SUC]
   THEN EVAL_TAC THEN METIS_TAC []);

val ThenStarThm = Q.prove
(`!r w n. sem (FUNPOW ($# r) n Epsilon) w ==> sem (Star r) w`,
 Induct_on `n` THENL [ALL_TAC, POP_ASSUM MP_TAC] THEN EVAL_TAC
   THEN RW_TAC list_ss [sem_def,FUNPOW_SUC] THENL
   [METIS_TAC [FLAT, EVERY_DEF],
    RES_TAC THEN Q.EXISTS_TAC `w1::wlist` 
      THEN METIS_TAC [EVERY_DEF,FLAT]]);

val Star_equals_nThen = Q.prove
(`!r w. sem (Star r) w = ?n. sem (FUNPOW ($# r) n Epsilon) w`,
 METIS_TAC [ThenStarThm, StarThenThm]);

val StarMonotone = Q.prove
(`!r w. sem r w ==> sem (Star r) w`,
 RW_TAC list_ss [sem_def]
  THEN Q.EXISTS_TAC `[w]` 
  THEN RW_TAC list_ss []);

val StarIdem = Q.prove
(`!r. sem (Star(Star r)) = sem (Star r)`,
 RW_TAC list_ss [sem_def,FUN_EQ_THM]
   THEN EQ_TAC THEN RW_TAC list_ss [] THENL
   [Induct_on `wlist` THENL
    [RW_TAC list_ss [] THEN METIS_TAC [FLAT,EVERY_DEF],
     RW_TAC list_ss [] THEN RES_TAC 
      THEN RULE_ASSUM_TAC (REWRITE_RULE [sem_def])
      THEN RW_TAC std_ss []
      THEN Q.EXISTS_TAC `wlist'' ++ wlist'`
      THEN RW_TAC list_ss [FLAT_APPEND_DISTRIB]],
    METIS_TAC [EVERY_MEM,StarMonotone]]);

val StarThenStar = Q.prove
(`!r. sem (Star r # Star r) = sem (Star r)`,
 RW_TAC list_ss [sem_def,FUN_EQ_THM]
   THEN EQ_TAC THEN RW_TAC list_ss [] THENL
   [METIS_TAC [EVERY_APPEND,FLAT_APPEND_DISTRIB],
    Cases_on `wlist` THENL
    [METIS_TAC [FLAT,EVERY_DEF,APPEND],
     MAP_EVERY Q.EXISTS_TAC [`FLAT [h]`, `FLAT t`]
      THEN RW_TAC list_ss [] THENL
      [Q.EXISTS_TAC `[h]` THEN FULL_SIMP_TAC list_ss [],
       METIS_TAC [EVERY_DEF]]]]);

(*---------------------------------------------------------------------------*)
(* "Smart" constructors, which build in some trivial optimizations.          *)
(*---------------------------------------------------------------------------*)

val SimpDisj_def = Define
 `SimpDisj r1 r2 = if r1 = Empty then r2 else
                   if r2 = Empty then r1 else
                   if r1 = r2 then r1 else (r1 + r2)`;

val SimpAnd_def = Define
 `SimpAnd r1 r2 = if (r1 = Empty) \/ (r2 = Empty) then Empty else
                  if r1 = r2 then r1 else (r1 & r2)`;

val SimpThen_def = Define
 `SimpThen r1 r2 = if (r1 = Empty) \/ (r2 = Empty) then Empty else
                   if r1 = Epsilon then r2 else
                   if r2 = Epsilon then r1 else (r1 # r2)`;

val SimpDisjCorrect = Q.prove
(`!r1 r2. sem (SimpDisj r1 r2) = sem (r1 + r2)`,
 RW_TAC list_ss [SimpDisj_def,sem_def,FUN_EQ_THM]);

val SimpAndCorrect = Q.prove
(`!r1 r2. sem (SimpAnd r1 r2) = sem (r1 & r2)`,
 RW_TAC list_ss [SimpAnd_def,sem_def,FUN_EQ_THM] THEN
 RW_TAC list_ss [sem_def]);

val SimpThenCorrect = Q.prove
(`!r1 r2. sem (SimpThen r1 r2) = sem (r1 # r2)`,
 RW_TAC list_ss [SimpThen_def,sem_def,FUN_EQ_THM] THEN
 RW_TAC list_ss [sem_def]);
    

(*---------------------------------------------------------------------------*)
(* Is Epsilon in the generated language of a regular expression?             *)
(* We bail out in the case of Prefix, by appealing to the semantics.         *)
(*---------------------------------------------------------------------------*)

val hasEpsilon_def = Define
  `(hasEpsilon Empty      = F) /\
   (hasEpsilon Epsilon    = T) /\
   (hasEpsilon Any        = F) /\
   (hasEpsilon (Symbol _) = F) /\
   (hasEpsilon (Not r)    = ~hasEpsilon r) /\
   (hasEpsilon (r1 + r2)  = hasEpsilon r1 \/ hasEpsilon r2) /\
   (hasEpsilon (r1 & r2)  = hasEpsilon r1 /\ hasEpsilon r2) /\
   (hasEpsilon (r1 # r2)  = hasEpsilon r1 /\ hasEpsilon r2) /\
   (hasEpsilon (Star _)   = T) /\
   (hasEpsilon (Prefix r) = ~(sem r = sem Empty))`;

val hasEpsilon_sem = Q.prove
(`!r. hasEpsilon r = sem r []`,
 Induct THEN RW_TAC list_ss [hasEpsilon_def,sem_def]
        THENL [METIS_TAC [EVERY_DEF,FLAT],
               RW_TAC list_ss [FUN_EQ_THM,sem_def]]);

(*---------------------------------------------------------------------------*)
(* Deriv x r finds a regex that generates the language obtained after taking *)
(* symbol x off the front of all strings in L(r). Starting from r, we can    *)
(* iteratively build up an automaton by taking Deriv a r for each a in the   *)
(* alphabet.                                                                 *)
(*---------------------------------------------------------------------------*)

val Deriv_def = 
 Define
  `(Deriv x Empty      = Empty) 
/\ (Deriv x Epsilon    = Empty) 
/\ (Deriv x Any        = Epsilon)
/\ (Deriv x (Symbol a) = if x=a then Epsilon else Empty)
/\ (Deriv x (Not P)    = Not (Deriv x P))
/\ (Deriv x (P+Q)      = SimpDisj (Deriv x P) (Deriv x Q))
/\ (Deriv x (P&Q)      = SimpAnd (Deriv x P) (Deriv x Q))
/\ (Deriv x (P#Q)      = SimpDisj(SimpThen (Deriv x P) Q)
                                 (if hasEpsilon P then Deriv x Q else Empty))
/\ (Deriv x (Star P)   = SimpThen (Deriv x P) (Star P))
/\ (Deriv x (Prefix P) = Prefix (Deriv x P))`;


(*---------------------------------------------------------------------------*)
(* Basic correctness property of Deriv is straightforward.                   *)
(*---------------------------------------------------------------------------*)

val semDeriv = Q.prove
(`!r w x. sem (Deriv x r) w = sem r (x::w)`,
 Induct THENL
 [RW_TAC list_ss [Deriv_def, sem_def],
  RW_TAC list_ss [Deriv_def, sem_def],
  RW_TAC list_ss [Deriv_def, sem_def],
  RW_TAC list_ss [Deriv_def, sem_def],
  RW_TAC list_ss [Deriv_def, sem_def],
  RW_TAC list_ss [Deriv_def, sem_def,SimpDisjCorrect],
  RW_TAC list_ss [Deriv_def, sem_def,SimpAndCorrect],
  RW_TAC list_ss [Deriv_def, sem_def,SimpThenCorrect,SimpDisjCorrect] THENL
  [REPEAT (STRIP_TAC ORELSE EQ_TAC) THEN RW_TAC list_ss [] THENL
   [MAP_EVERY Q.EXISTS_TAC [`x::w1`, `w2`] THEN RW_TAC list_ss [],
    FULL_SIMP_TAC list_ss [hasEpsilon_sem] 
      THEN MAP_EVERY Q.EXISTS_TAC [`[]`, `x::w`] THEN RW_TAC list_ss [],
    Cases_on `w1` THENL
    [FULL_SIMP_TAC list_ss [],
     DISJ1_TAC THEN FULL_SIMP_TAC list_ss [] THEN METIS_TAC []]],
   REPEAT (STRIP_TAC ORELSE EQ_TAC) THEN RW_TAC list_ss [] THENL
   [MAP_EVERY Q.EXISTS_TAC [`x::w1`, `w2`] THEN RW_TAC list_ss [],
    Cases_on `w1` THENL
    [FULL_SIMP_TAC list_ss [hasEpsilon_sem],
     FULL_SIMP_TAC list_ss [] THEN METIS_TAC []]]],
  RW_TAC list_ss [Deriv_def, sem_def,SimpThenCorrect] 
    THEN WEAKEN_TAC (K true) 
    THEN REPEAT (STRIP_TAC ORELSE EQ_TAC) THEN RW_TAC list_ss [] THENL
    [Q.EXISTS_TAC `(x::w1) :: wlist` THEN RW_TAC list_ss [],
     Cases_on `NULL (FLAT wlist)` THENL
     [FULL_SIMP_TAC list_ss [NULL_EQ_NIL],
      FULL_SIMP_TAC list_ss [NULL_FLAT_THM] 
        THEN IMP_RES_TAC FIRST_EXISTS_THM 
        THEN Cases_on `w'` THENL
             [FULL_SIMP_TAC list_ss [],
              MAP_EVERY Q.EXISTS_TAC [`t`, `FLAT suffix`]
                THEN POP_ASSUM (K ALL_TAC) 
                THEN BasicProvers.VAR_EQ_TAC
                THEN `$~ o $~ o NULL = NULL` 
                     by (RW_TAC list_ss [combinTheory.o_DEF] THEN METIS_TAC [])
                THEN POP_ASSUM SUBST_ALL_TAC
                THEN `FLAT prefix = []` by METIS_TAC [NULL_EQ_NIL,NULL_FLAT_THM]
                THEN RULE_ASSUM_TAC (REWRITE_RULE [FLAT_APPEND_DISTRIB])
                THEN POP_ASSUM SUBST_ALL_TAC
                THEN RULE_ASSUM_TAC (SIMP_RULE list_ss [])
                THEN METIS_TAC []]]],
  RW_TAC list_ss [Deriv_def, sem_def]]);


(*---------------------------------------------------------------------------*)
(* Take the derivative with respect to a string.                             *)
(*---------------------------------------------------------------------------*)

val DerivString_def = Define
  `(DerivString [] r = r) /\
   (DerivString (h::t) r = DerivString t (Deriv h r))`;

(*---------------------------------------------------------------------------*)
(* The matching algorithm just runs DerivString and checks for Epsilon.      *)
(*---------------------------------------------------------------------------*)

val Matches_def = 
 Define 
   `Matches r w = hasEpsilon (DerivString w r)`;


(*---------------------------------------------------------------------------*)
(* Correctness of matcher follows by induction.                              *)
(*---------------------------------------------------------------------------*)

val MatchesCorrect = Q.prove
(`!r w. sem r w =  Matches r w`,
 SIMP_TAC list_ss [Matches_def] 
  THEN Induct_on `w` 
  THEN RW_TAC list_ss [DerivString_def]
  THENL [METIS_TAC [hasEpsilon_sem],RW_TAC list_ss [GSYM semDeriv]]);


(*---------------------------------------------------------------------------*)
(* Tests for the matcher. Done by inference!                                 *)
(*---------------------------------------------------------------------------*)
(*
load "stringLib";
fun CHECK r s = 
   Count.apply EVAL 
      ``Matches (^r : char regex) (EXPLODE ^(stringSyntax.fromMLstring s))``;

val Zero  = ``Symbol #"0"``;
val One   = ``Symbol #"1"``;
val Two   = ``Symbol #"2"``;
val Three = ``Symbol #"3"``;
val a     = ``Symbol #"a"``;
val b     = ``Symbol #"b"``;
val c     = ``Symbol #"c"``;
val r0    =  ``^One # ^Two``;
val r1    =  ``Star ^r0``;
val r2    =  ``Star Any # ^One``;
val r3    =  ``^r2 # ^r1``;

(* val true  = *) CHECK r0 "12";
(* val true  = *) CHECK r1 "12";
(* val true  = *) CHECK r1 "1212";
(* val true  = *) CHECK r1 "12121212121212121212121212121212";
(* val false = *) CHECK r1 "12123";
(* val false = *) CHECK r1 "121212121212121212121212121212122";
(* val false = *) CHECK r2 "";
(* val true  = *) CHECK r2 "1";
(* val true  = *) CHECK r2 "0001";
(* val false = *) CHECK r2 "0002";
(* val true  = *) CHECK r3 "00011212";
(* val false = *) CHECK r3 "00011213";
(* val true  = *) CHECK ``Star(Star Any)`` "";
(* val true  = *) CHECK ``Star(Star Any):char regex`` "0";
(* val true  = *) CHECK ``Star(Star Any):char regex`` "0123";
(* val true  = *) CHECK ``Star (Any # Star Any): char regex`` "0";
(* val true  = *) CHECK ``Star (Any # Star Any):char regex`` "01";
(* val true  = *) CHECK ``Star (Any # Star Any):char regex`` "012";
(* val true  = *) CHECK ``^a # Star(^a + ^b) # Star(^b # ^a)`` "abba";

(*---------------------------------------------------------------------------*)
(*  At most 2 a's. Alphabet = {a,b}                                          *) 
(*---------------------------------------------------------------------------*)

val AtMostTwo_a = ``Star ^b + Star ^b # (^a + ^a # Star ^b # ^a) # Star ^b``;

CHECK AtMostTwo_a "";
CHECK AtMostTwo_a "b";
CHECK AtMostTwo_a "a";
CHECK AtMostTwo_a "aa";
CHECK AtMostTwo_a "ab";
CHECK AtMostTwo_a "ba";
CHECK AtMostTwo_a "bb";
CHECK AtMostTwo_a "abbbbabbbb";
CHECK AtMostTwo_a "bbbbabbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb";
CHECK AtMostTwo_a "bbbbabbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbba";
CHECK AtMostTwo_a "bbbbabbbbbbbbbbbbbbbbbbbbbbbbbbbabbbbbbbbbbbbbbbbbbbbbbbbba";
(* false *) CHECK AtMostTwo_a "abbbbabbbab";

(*---------------------------------------------------------------------------*)
(* Exactly 2 a's. Alphabet = {a,b}                                           *)
(*---------------------------------------------------------------------------*)

val ExactlyTwo_a = ``Star ^b # ^a # Star ^b # ^a # Star ^b``;

(* false *) CHECK ExactlyTwo_a "";
(* false *) CHECK ExactlyTwo_a "b";
(* false *) CHECK ExactlyTwo_a "a";
(* true *)  CHECK ExactlyTwo_a "aa";
(* false *) CHECK ExactlyTwo_a "ab";
(* false *) CHECK ExactlyTwo_a "ba";
(* false *) CHECK ExactlyTwo_a "bb";
(* true *)  CHECK ExactlyTwo_a "abbbbabbbb";
(* true *)  CHECK ExactlyTwo_a 
               "bbbbabbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbab";
(* false *) CHECK ExactlyTwo_a "abbbbabbbab";

(*---------------------------------------------------------------------------*)
(* All strings of length 0-3                                                 *)
(*---------------------------------------------------------------------------*)

val UpTo3 =  ``Epsilon + Any + Any#Any + Any#Any#Any : char regex``;

(* true *) CHECK UpTo3 "";
(* true *) CHECK UpTo3 "b";
(* true *) CHECK UpTo3 "a";
(* true *) CHECK UpTo3 "aa";
(* false *) CHECK UpTo3 
              "abbbbabbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb";

(*---------------------------------------------------------------------------*)
(* All strings with no occurrences of aa or bb                               *)
(*---------------------------------------------------------------------------*)

val NoDouble = ``Any + Star (^a # ^b) + Star (^b # ^a)``;

(* true *)  CHECK NoDouble "";
(* true *)  CHECK NoDouble "a";
(* true *)  CHECK NoDouble "b";
(* false *) CHECK NoDouble "aa";
(* true *)  CHECK NoDouble "ab";
(* true *)  CHECK NoDouble "ba";
(* false *) CHECK NoDouble "bb";
(* true *)  CHECK NoDouble 
              "ababababababababababababababababababababababababababab";
(* false *) CHECK NoDouble 
              "abababababababababababbababababababababababababababab";

(*---------------------------------------------------------------------------*)
(* Same again, using Not operator                                            *)
(*---------------------------------------------------------------------------*)

val NoDub =  ``Not (Star Any # ((^a # ^a) + (^b # ^b)) # Star Any)``;

(* true *)  CHECK NoDub "";
(* true *)  CHECK NoDub "a";
(* true *)  CHECK NoDub "b";
(* false *) CHECK NoDub "aa";
(* true *)  CHECK NoDub "ab";
(* true *)  CHECK NoDub "ba";
(* false *) CHECK NoDub "bb";
(* true *)  CHECK NoDub 
              "ababababababababababababababababababababababababababab";
(* false *) CHECK NoDub 
              "abababababababababababbababababababababababababababab";

(*---------------------------------------------------------------------------*)
(* All strings with at least two consecutive zeros and not ending in 01      *)
(*---------------------------------------------------------------------------*)

val pat = ``(Star Any # ^Zero # ^Zero # Star Any) & 
            Not (Star Any # ^Zero # ^One)``;

(* true *) CHECK pat "00";
(* false *) CHECK pat "001";
(* true *) CHECK pat "0111010101010111111000000";
(* true *) CHECK pat "011101010101011111100000010101000111111111111111111111";
(* true *) CHECK pat "0011010101010111111000000101010001111111111111111111110";
(* false *) CHECK pat "0011010101010111111000000101010001111111111111111111101";

(*---------------------------------------------------------------------------*)
(* All strings with at least three consecutive ones and not ending in 01 or  *)
(*   consisting of all ones.                                                 *)
(*---------------------------------------------------------------------------*)

val pat = ``(Star Any # ^One # ^One # ^One # Star Any) & 
            Not (Star Any # ^Zero # ^One + ^One # Star ^One)``;

(* true *)  CHECK pat "01110";
(* false *) CHECK pat "1";
(* false *) CHECK pat "11";
(* false *) CHECK pat "111";
(* false *) CHECK pat "1111111111111111111111111111111111";
(* false *) CHECK pat 
             "11111111111111111111111111111111111111111111111111111111";
(* false *) CHECK pat 
             "1111111111111111111111111111111111111111111111111111111111111111";
(* true *)  CHECK pat "0111010101010111111000000";
(* true *)  CHECK pat "01101010101011111100000010101000111111111111111111111";
(* true *)  CHECK pat "10001101010101011000000101010001111111111111111111110";
(* false *) CHECK pat "0011010101010111111000000101010001111111111111111111101";

*)

(*---------------------------------------------------------------------------*)
